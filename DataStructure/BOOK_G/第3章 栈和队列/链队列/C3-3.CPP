// C3-3.cpp 链队列(存储结构由C3-3.h定义)的基本操作

#include "C3-3.h"

Status InitQueue(LinkQueue &Q)
{	// 构造一个空队列Q
	if(!(Q.front=Q.rear=(QueuePtr)malloc(sizeof(QNode))))  exit(OVERFLOW);
	Q.front->next=NULL;
	return OK;
}

Status DestroyQueue(LinkQueue &Q)
{	// 销毁队列Q(无论空否均可)
	while(Q.front)
	{
		Q.rear=Q.front->next;
		free(Q.front);
		Q.front=Q.rear;
	}
	return OK;
}

Status ClearQueue(LinkQueue &Q)
{	// 将Q清为空队列
	QueuePtr p,q;
	Q.rear=Q.front;
	p=Q.front->next;
	Q.front->next=NULL;
	while(p)
	{
		q=p; p=p->next; free(q);
	}
	return OK;
}

Status QueueEmpty(LinkQueue Q)
{	// 若Q为空队列,则返回TRUE,否则返回FALSE
	if(Q.front==Q.rear) return TRUE; else return FALSE;
}

int QueueLength(LinkQueue Q)
{	// 求队列的长度
	int i=0;
	QueuePtr p;
	p=Q.front;
	while(Q.rear!=p)
	{
		i++; p=p->next;
	}
	return i;
}

SElemType GetHead(LinkQueue Q)
{    //队列不空,则返回队头元素,否则返回ERROR
	QueuePtr p;
	SElemType e;
	if(Q.front==Q.rear) return ERROR;
	p=Q.front->next;
	e=p->data;
	return e;
}

Status EnQueue(LinkQueue &Q,SElemType e)
{	// 插入元素e为Q的新的队尾元素
	QueuePtr p;
	if(!(p=(QueuePtr)malloc(sizeof(QNode)))) // 存储分配失败
		exit(OVERFLOW);
	p->data=e;
	p->next=NULL;
	Q.rear->next=p;
	Q.rear=p;
	return OK;
}

SElemType DeQueue(LinkQueue &Q)
{	//队列不空,删除队头元素并返回,否则返回ERROR
	QueuePtr p;
	SElemType e;
	if(Q.front==Q.rear) return ERROR;
	p=Q.front->next;
	e=p->data;
	Q.front->next=p->next;
	if(Q.rear==p) Q.rear=Q.front;
	free(p);
	return e;
}

Status QueueTraverse(LinkQueue Q)
{	// 从队头到队尾依次对队列Q中每个元素调用函数visit()函数进行访问
	QueuePtr p;
	p=Q.front->next;
	while(p)
	{
		visit(p->data);
		p=p->next;
	}
	printf("\n");
	return OK;
}

void visit(SElemType e)
{
   printf("%d ",e);
}